<!DOCTYPE html>
<html lang="es">
<head>
    <meta name="google-adsense-account" content="ca-pub-7958789052344952">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego Multijugador de Pingï¿½inos</title>
    <style>
        
        h1 {
    font-size: 16px; /* Tamaï¿½o pequeï¿½o de letra */
    text-align: center; /* Centra el texto horizontalmente */
    margin: 0; /* Elimina mï¿½rgenes superiores e inferiores */
    padding: 10px 0; /* Un poco de espacio para separaciï¿½n */
    position: absolute; /* Posiciona el <h1> en la parte superior */
    top: 0; /* Coloca el <h1> en la parte superior de la pï¿½gina */
    left: 0;
    right: 0;
}
        #reenter {
            fdisplay: block; /* Hace que el botï¿½n se comporte como un bloque */
    margin: 20px auto; /* Centra el botï¿½n horizontalmente y aï¿½ade espacio arriba */
    padding: 10px 20px; /* Aï¿½ade algo de espacio al botï¿½n */
    font-size: 14px; /* Ajusta el tamaï¿½o del texto del botï¿½n */
        }

        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #33CCFF; /* Fondo por defecto */
            position: relative; /* Para posicionar elementos hijos */
            transition: background-color 0.5s; /* Transiciï¿½n suave para el cambio de fondo */
        }
        
        .game-area {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 350px;
            height: 400px;
            background: url('2.png') no-repeat center center;
            background-size: 100% 100%;
            border: 2px solid black;
            overflow: hidden;
            padding: 20px;
            box-sizing: border-box;
            z-index: 1; /* Asegura que estï¿½ por debajo de las ï¿½reas de chat e input */
        }

        .player {
            position: absolute;
            width: 50px;
            height: 50px;
            pointer-events: none; /* Para que los jugadores no intercepten clics */
        }
        
        .message {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid black;
            padding: 2px;
            font-size: 12px;
            white-space: normal; /* Permitir saltos de lï¿½nea */
            word-wrap: break-word; /* Permitir romper palabras largas */
            max-width: 150px; /* Ancho mï¿½ximo del mensaje */
            pointer-events: none;
        }
        
        .chat-area {
            position: absolute;
            bottom: 100px; /* Ajustado para evitar superposiciï¿½n con input-area */
            width: 350px;
            max-height: 200px; /* Aumentado para mostrar mï¿½s mensajes */
            overflow-y: auto;
            padding: 5px;
            box-sizing: border-box;
            z-index: 2;
            background-color: rgba(255, 255, 255, 0.8);
            border: 2px solid black;
        }
        
        .input-area {
            position: absolute;
            bottom: 50px; /* Ajustado para evitar superposiciï¿½n con chat-area */
            width: 350px;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            z-index: 2;
            background-color: rgba(255, 255, 255, 0.9); /* Fondo para mejor visibilidad */
            border: 2px solid black;
        }
        
        input {
            width: 80%;
            padding: 5px;
            font-size: 14px;
        }

        button {
            width: 18%;
            padding: 5px;
            font-size: 14px;
            cursor: pointer;
        }

        /* Clase para ocultar elementos */
        .hidden {
            display: none;
        }

    </style>
</head>
<body>
 <h1 >Has salido del ï¿½rea de juego.</h1>
    <!-- Opcional: Botï¿½n para reingresar al ï¿½rea de juego principal -->
    <button id="reenter">Reingresar al Juego</button>

    <div class="game-area" id="gameArea"></div>
    <div class="chat-area" id="chatArea"></div>
    <div class="input-area">
        <input type="text" id="messageInput" maxlength="60" placeholder="Escribe tu mensaje (mï¿½x. 60 caracteres)" />
        <button id="sendMessage">Enviar</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const players = {};
        const gameArea = document.getElementById('gameArea');
        const chatArea = document.getElementById('chatArea');
        const messageInput = document.getElementById('messageInput');
        const sendMessageButton = document.getElementById('sendMessage');
        const reenterButton = document.getElementById('reenter');

        reenterButton.addEventListener('click', () => {
            // Emitir evento para reingresar al ï¿½rea de juego
            socket.emit('reenterGameArea');
        });

        // Manejar el evento 'switchedArea' para redirigir de vuelta a index.html
        socket.on('switchedArea', (newArea) => {
            if (newArea === 'NORMAL') {
                window.location.href = '/index.html';
            }
        });
        

        // Obtener las imï¿½genes de movimiento
        const penguinImages = {
            up: ['arriba1.png', 'arriba2.png'],
            down: ['abajo1.png', 'abajo2.png'],
            left: ['izquierda1.png', 'izquierda2.png'],
            right: ['derecha1.png', 'derecha2.png']
        };

        // Funciï¿½n para crear un nuevo jugador
        function createPlayer(id, x, y) {
            const playerDiv = document.createElement('img');
            playerDiv.src = 'pingu.png'; // Asegï¿½rate de que la imagen estï¿½ en la carpeta pï¿½blica
            playerDiv.className = 'player';
            playerDiv.id = id;
            playerDiv.style.left = `${x}px`;
            playerDiv.style.top = `${y}px`;
            gameArea.appendChild(playerDiv);
            
            // Almacenar el jugador en el objeto players con posiciï¿½n anterior
            players[id] = { div: playerDiv, messageDivs: [], prevX: x, prevY: y };
        }

        // Funciï¿½n para mover el pingï¿½ino con animaciï¿½n de imï¿½genes
        function movePenguin(penguin, targetX, targetY, direction) {
            let frame = 0;
            const steps = 60; // Nï¿½mero total de pasos para el movimiento
            const currentX = parseFloat(penguin.style.left);
            const currentY = parseFloat(penguin.style.top);

            const dx = targetX - currentX;
            const dy = targetY - currentY;
            const stepX = dx / steps;
            const stepY = dy / steps;

            // Cambiar las imï¿½genes cada ciertos pasos
            const intervalId = setInterval(() => {
                penguin.src = penguinImages[direction][frame % penguinImages[direction].length];
                frame++;
            }, 200);

            let stepCount = 0;
            const moveInterval = setInterval(() => {
                if (stepCount < steps) {
                    penguin.style.left = `${currentX + stepX * stepCount}px`;
                    penguin.style.top = `${currentY + stepY * stepCount}px`;
                    stepCount++;
                } else {
                    clearInterval(moveInterval);
                    clearInterval(intervalId);
                    penguin.src = 'pingu.png'; // Imagen final cuando el pingï¿½ino se detiene
                }
            }, 16); // Ajusta este valor para controlar la velocidad del movimiento
        }

        // Funciï¿½n para crear el div del mensaje
        function createMessageDiv(id, message) {
            const player = players[id];

            // Limitar a 2 mensajes, eliminar el mï¿½s antiguo si ya hay 1
            if (player.messageDivs.length >= 1) {
                const oldestMessageDiv = player.messageDivs.shift(); // Eliminar el mï¿½s antiguo
                oldestMessageDiv.remove(); // Eliminar el div del DOM
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.textContent = message;

            // Colocar el mensaje inicialmente a la derecha del pingï¿½ino
            const playerX = parseFloat(player.div.style.left);
            const playerY = parseFloat(player.div.style.top);
            messageDiv.style.left = `${playerX + 60}px`; 
            messageDiv.style.top = `${playerY}px`; 

            gameArea.appendChild(messageDiv);
            player.messageDivs.push(messageDiv); 

            // Eliminar el mensaje despuï¿½s de 10 segundos
            setTimeout(() => {
                messageDiv.remove();
                player.messageDivs = player.messageDivs.filter((div) => div !== messageDiv);
            }, 10000);
        }

        // Funciï¿½n para mover el mensaje
        function moveMessage(id) {
            const player = players[id];
            if (player && player.messageDivs.length > 0) {
                const playerX = parseFloat(player.div.style.left);
                const playerY = parseFloat(player.div.style.top);

                player.messageDivs.forEach((messageDiv, index) => {
                    messageDiv.style.left = `${playerX + 60}px`; 
                    messageDiv.style.top = `${playerY + (index * 20)}px`; 
                });
            }
        }

        // Manejo de jugadores actuales
        socket.on('currentPlayers', (currentPlayers) => {
            for (let id in currentPlayers) {
                createPlayer(id, currentPlayers[id].x, currentPlayers[id].y);
            }
        });

        // Notificaciï¿½n de nuevo jugador
        socket.on('newPlayer', (data) => {
            createPlayer(data.id, data.player.x, data.player.y);
        });

        // Movimiento de otro jugador
        socket.on('playerMoved', (data) => {
            const player = players[data.id];
            if (player) {
                const prevX = player.prevX;
                const prevY = player.prevY;
                const newX = data.player.x;
                const newY = data.player.y;

                // Determinar la direcciï¿½n del movimiento
                let direction;
                if (newY < prevY && Math.abs(newX - prevX) < Math.abs(newY - prevY)) direction = 'up';
                else if (newY > prevY && Math.abs(newX - prevX) < Math.abs(newY - prevY)) direction = 'down';
                else if (newX < prevX) direction = 'left';
                else if (newX > prevX) direction = 'right';

                // Actualizar posiciones previas
                player.prevX = newX;
                player.prevY = newY;

                // Mover el pingï¿½ino y animar
                movePenguin(player.div, newX, newY, direction);
            }
        });

        // Notificaciï¿½n de jugador desconectado
        socket.on('playerDisconnected', (id) => {
            const player = players[id];
            if (player) {
                player.div.remove();
                player.messageDivs.forEach(div => div.remove()); // Eliminar mensajes del jugador desconectado
                delete players[id];
            }
        });

        // Al hacer clic para mover el pingï¿½ino dentro del gameArea
        gameArea.addEventListener('click', (event) => {
            const rect = gameArea.getBoundingClientRect();
            const x = event.clientX - rect.left; // Posiciï¿½n X del clic
            const y = event.clientY - rect.top; // Posiciï¿½n Y del clic

            // Limitar la posiciï¿½n del pingï¿½ino dentro del ï¿½rea de juego
            const limitedX = Math.max(0, Math.min(rect.width - 50, x)); // 50 es el ancho del pingï¿½ino
            const limitedY = Math.max(0, Math.min(rect.height - 50, y)); // 50 es la altura del pingï¿½ino

            // Obtener la posiciï¿½n actual del jugador
            const currentPlayer = players[socket.id];
            if (!currentPlayer) return; // Asegï¿½rate de que el jugador exista

            // Determinar la direcciï¿½n del movimiento
            let direction;
            const currentX = parseFloat(currentPlayer.div.style.left);
            const currentY = parseFloat(currentPlayer.div.style.top);
            
            if (limitedY < currentY && Math.abs(limitedX - currentX) < Math.abs(limitedY - currentY)) direction = 'up';
            else if (limitedY > currentY && Math.abs(limitedX - currentX) < Math.abs(limitedY - currentY)) direction = 'down';
            else if (limitedX < currentX) direction = 'left';
            else if (limitedX > currentX) direction = 'right';

            // Mover el pingï¿½ino y animar
            movePenguin(currentPlayer.div, limitedX, limitedY, direction);
            socket.emit('movePlayer', { x: limitedX, y: limitedY });

            // Actualizar posiciones previas
            currentPlayer.prevX = limitedX;
            currentPlayer.prevY = limitedY;
        });

        // ----- Modificaciones Aï¿½adidas Aquï¿½ -----
        
      
      

        // Cuando se desconecta un jugador, asegurarse de que sus elementos sean ocultados correctamente
        socket.on('playerDisconnected', (id) => {
            const player = players[id];
            if (player) {
                player.div.remove();
                player.messageDivs.forEach(div => div.remove()); // Eliminar mensajes del jugador desconectado
                delete players[id];
            }
        });

        // Enviar mensaje al presionar "Enter"
        messageInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });

        // Funciï¿½n para enviar el mensaje
        function sendMessage() {
            const message = messageInput.value.trim();

            if (message.length > 60) { // Validaciï¿½n de longitud
                alert('El mensaje no puede tener mï¿½s de 60 caracteres.');
                return;
            }

            if (message) {
                socket.emit('sendMessage', message);
                messageInput.value = ''; // Limpiar el campo de entrada
            }
        }

        // Recibir mensaje de otros jugadores
        socket.on('receiveMessage', (data) => {
            createMessageDiv(data.id, data.message);
            moveMessage(data.id);
        });

        // Actualizar la posiciï¿½n del mensaje al mover el jugador
        function updateMessages() {
            for (const id in players) {
                moveMessage(id);
            }
        }

        setInterval(updateMessages, 60); 

        // Fragmento cï¿½digo desconexiï¿½n por inactividad
        let inactivityTimer;

        function handleInactivity() {
            alert("Has estado inactivo durante 10 minutos. Actualiza la pï¿½gina para continuar pingï¿½ineando.");
            // Aquï¿½ puedes agregar el cï¿½digo para desconectar al usuario si es necesario
        }

        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(handleInactivity, 600000);
        }

        document.addEventListener('keydown', resetInactivityTimer);
        document.addEventListener('mousemove', resetInactivityTimer);
        document.addEventListener('click', resetInactivityTimer);
        
        // Inicializar el temporizador al cargar la pï¿½gina
        resetInactivityTimer();
    </script>
</body>
</html>



