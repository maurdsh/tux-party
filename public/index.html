<!DOCTYPE html>
<html lang="es">
<head>
    <meta name="google-adsense-account" content="ca-pub-7958789052344952">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Juego Multijugador de Pingüinos</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #33CCFF;
            position: relative; /* Para posicionar elementos hijos */
        }
        
        .game-area {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 350px;
            height: 400px;
            background: url('1.png') no-repeat center center;
            background-size: 100% 100%;
            border: 2px solid black;
            overflow: visible; /* Cambiado de hidden a visible */
            padding: 20px;
            box-sizing: border-box;
            z-index: 1; /* Asegura que esté por debajo de las áreas de chat e input */
        }

        .player {
            position: relative; /* Cambiado de absolute a relative */
            width: 50px;
            height: 50px; /* Asegura que el div del pingüino tenga altura */
        }
        
       .message {
    position: absolute;
    top: -20px; /* Posiciona el mensaje encima del pingüino */
    left: 120%; /* Centra horizontalmente el mensaje */
    transform: translateX(-50%); /* Centra el mensaje */
    background-color: rgba(255, 255, 255, 0.8);
    border: 1px solid black;
    padding: 2px;
    font-size: 12px;
    white-space: pre-wrap; /* Permitir saltos de línea y respetar espacios */
    word-wrap: break-word; /* Permitir romper palabras largas */
    max-width: 150px; /* Ancho máximo del mensaje */
    pointer-events: none;
    z-index: 3; /* Por encima del pingüino */
}

       
        .chat-area {
            position: absolute;
            bottom: 100px; /* Ajustado para evitar superposición con input-area */
            width: 350px;
            max-height: 60px;
            overflow-y: auto;
            padding: 5px;
            box-sizing: border-box;
            z-index: 2;
        }
        
        .input-area {
            position: absolute;
            bottom: 50px; /* Ajustado para evitar superposición con chat-area */
            width: 350px;
            display: flex;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
            z-index: 2;
            background-color: rgba(255, 255, 255, 0.9); /* Fondo para mejor visibilidad */
        }
        
        input {
            width: 80%;
            padding: 5px;
            font-size: 14px;
        }

        button {
            width: 18%;
            padding: 5px;
            font-size: 14px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <div class="game-area" id="gameArea"></div>
    <div class="chat-area" id="chatArea"></div>
    <div class="input-area">
        <input type="text" id="messageInput" maxlength="60" placeholder="Escribe tu mensaje (máx. 60 caracteres)" />

        <button id="sendMessage">Enviar</button>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const players = {};
        const gameArea = document.getElementById('gameArea');
        const chatArea = document.getElementById('chatArea');
        const messageInput = document.getElementById('messageInput');
        const sendMessageButton = document.getElementById('sendMessage');

        // Obtener las imágenes de movimiento
        const penguinImages = {
            up: ['arriba1.png', 'arriba2.png'],
            down: ['abajo1.png', 'abajo2.png'],
            left: ['izquierda1.png', 'izquierda2.png'],
            right: ['derecha1.png', 'derecha2.png']
        };

        // Función para crear un nuevo jugador
        function createPlayer(id, x, y) {
            const playerDiv = document.createElement('div'); // Cambiado de 'img' a 'div' para mejor manejo
            playerDiv.className = 'player';
            playerDiv.id = id;
            playerDiv.style.left = `${x}px`;
            playerDiv.style.top = `${y}px`;
            gameArea.appendChild(playerDiv);

            const playerImg = document.createElement('img');
            playerImg.src = 'pingu.png'; // Asegúrate de que la imagen esté en la carpeta pública
            playerImg.style.width = '100%'; // Para que la imagen ocupe todo el div
            playerDiv.appendChild(playerImg);

            // Almacenar el jugador en el objeto players con posición anterior
            players[id] = { div: playerDiv, messageDivs: [], prevX: x, prevY: y };
        }

        // Función para mover el pingüino con animación de imágenes
        function movePenguin(penguin, targetX, targetY, direction) {
            let frame = 0;
            const steps = 60; // Número total de pasos para el movimiento
            const currentX = parseFloat(penguin.style.left);
            const currentY = parseFloat(penguin.style.top);

            const dx = targetX - currentX;
            const dy = targetY - currentY;
            const stepX = dx / steps;
            const stepY = dy / steps;

            // Cambiar las imágenes cada ciertos pasos
            const intervalId = setInterval(() => {
                const playerImg = penguin.querySelector('img');
                playerImg.src = penguinImages[direction][frame % penguinImages[direction].length];
                frame++;
            }, 200);

            let stepCount = 0;
            const moveInterval = setInterval(() => {
                if (stepCount < steps) {
                    penguin.style.left = `${currentX + stepX * stepCount}px`;
                    penguin.style.top = `${currentY + stepY * stepCount}px`;
                    stepCount++;
                } else {
                    clearInterval(moveInterval);
                    clearInterval(intervalId);
                    const playerImg = penguin.querySelector('img');
                    playerImg.src = 'pingu.png'; // Imagen final cuando el pingüino se detiene
                }
            }, 16); // Ajusta este valor para controlar la velocidad del movimiento
        }

        // Función para crear el div del mensaje con máximo de 3 renglones y 20 caracteres por línea
// Función para crear el div del mensaje con máximo de 3 renglones y 20 caracteres por línea
// Función para crear el div del mensaje con máximo de 3 renglones y 20 caracteres por línea
function createMessageDiv(id, message) {
    const player = players[id];

    if (!player) {
        console.log(`Jugador ${id} no encontrado`);
        return;
    }

    // Limitar a 2 mensajes, eliminar el más antiguo si ya hay 1
    if (player.messageDivs.length >= 1) {
        const oldestMessageDiv = player.messageDivs.shift(); // Eliminar el más antiguo
        oldestMessageDiv.remove(); // Eliminar el div del DOM
    }

    // Limitar el mensaje a un máximo de 60 caracteres y dividir en líneas de 20
    const maxLineLength = 20;
    const formattedMessage = message.slice(0, 60).trim(); // Asegurarse de que no exceda los 60 caracteres y eliminar espacios iniciales/finales
    let lines = [];
    
    // Dividir el mensaje en líneas de 20 caracteres
    while (formattedMessage.length > 0) {
        // Tomar la primera línea de hasta 20 caracteres
        let line = formattedMessage.slice(0, maxLineLength);
        
        // Si hay un espacio en la línea, recortarlo hasta el último espacio para evitar cortar palabras
        if (line.length === maxLineLength && formattedMessage[maxLineLength] !== ' ') {
            const lastSpaceIndex = line.lastIndexOf(' ');
            if (lastSpaceIndex !== -1) {
                line = line.slice(0, lastSpaceIndex); // Recortar hasta el último espacio
            }
        }

        lines.push(line); // Agregar la línea a las líneas
        formattedMessage = formattedMessage.slice(line.length).trim(); // Recortar el mensaje original
    }

    // Limitar el número de líneas a 3
    lines = lines.slice(0, 3);

    // Unir las líneas en un solo string con saltos de línea
    const messageContent = lines.join('\n');

    // Crear un nuevo div para el mensaje
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message';
    messageDiv.textContent = messageContent; // Mostrar el mensaje formateado

    // Asegurarse de que el mensajeDiv se agregue correctamente al jugador
    player.div.appendChild(messageDiv);

    player.messageDivs.push(messageDiv); // Almacenar el div en el jugador

    console.log(`Mensaje creado para ${id}: ${message}`); // Depuración

    // Eliminar el mensaje después de 10 segundos
    setTimeout(() => {
        messageDiv.remove();
        player.messageDivs = player.messageDivs.filter((div) => div !== messageDiv);
    }, 10000);
}

        // Manejo de jugadores actuales
        socket.on('currentPlayers', (currentPlayers) => {
            for (let id in currentPlayers) {
                createPlayer(id, currentPlayers[id].x, currentPlayers[id].y);
            }
        });

        // Notificación de nuevo jugador
        socket.on('newPlayer', (data) => {
            createPlayer(data.id, data.player.x, data.player.y);
        });

        // Movimiento de otro jugador
        socket.on('playerMoved', (data) => {
            const player = players[data.id];
            if (player) {
                const prevX = player.prevX;
                const prevY = player.prevY;
                const newX = data.player.x;
                const newY = data.player.y;

                // Determinar la dirección del movimiento
                let direction;
                if (newY < prevY && Math.abs(newX - prevX) < Math.abs(newY - prevY)) direction = 'up';
                else if (newY > prevY && Math.abs(newX - prevX) < Math.abs(newY - prevY)) direction = 'down';
                else if (newX < prevX) direction = 'left';
                else if (newX > prevX) direction = 'right';

                // Actualizar posiciones previas
                player.prevX = newX;
                player.prevY = newY;

                // Mover el pingüino y animar
                movePenguin(player.div, newX, newY, direction);
            }
        });

        // Notificación de jugador desconectado
        socket.on('playerDisconnected', (id) => {
            const player = players[id];
            if (player) {
                player.div.remove();
                // No es necesario eliminar los mensajes ya que son hijos del div del jugador
                delete players[id];
            }
        });

        // Al hacer clic para mover el pingüino dentro del gameArea
        gameArea.addEventListener('click', (event) => {
            const rect = gameArea.getBoundingClientRect();
            const x = event.clientX - rect.left; // Posición X del clic
            const y = event.clientY - rect.top; // Posición Y del clic

            // Limitar la posición del pingüino dentro del área de juego
            const limitedX = Math.max(0, Math.min(rect.width - 50, x)); // 50 es el ancho del pingüino
            const limitedY = Math.max(0, Math.min(rect.height - 50, y)); // 50 es la altura del pingüino

            // Obtener la posición actual del jugador
            const currentPlayer = players[socket.id];
            if (!currentPlayer) return; // Asegúrate de que el jugador exista

            // Determinar la dirección del movimiento
            let direction;
            const currentX = parseFloat(currentPlayer.div.style.left);
            const currentY = parseFloat(currentPlayer.div.style.top);
            
            if (limitedY < currentY && Math.abs(limitedX - currentX) < Math.abs(limitedY - currentY)) direction = 'up';
            else if (limitedY > currentY && Math.abs(limitedX - currentX) < Math.abs(limitedY - currentY)) direction = 'down';
            else if (limitedX < currentX) direction = 'left';
            else if (limitedX > currentX) direction = 'right';

            // Mover el pingüino y animar
            movePenguin(currentPlayer.div, limitedX, limitedY, direction);
            socket.emit('movePlayer', { x: limitedX, y: limitedY });

            // Actualizar posiciones previas
            currentPlayer.prevX = limitedX;
            currentPlayer.prevY = limitedY;
        });

        // ----- Modificaciones Añadidas Aquí -----
        
        // Evitar que el clic en el botón "Enviar" propague el evento
        sendMessageButton.addEventListener('click', function(event) {
            event.stopPropagation(); // Detiene la propagación del clic
            sendMessage();
        });

        // Evitar que el clic en el campo de entrada de mensajes propague el evento
        messageInput.addEventListener('click', function(event) {
            event.stopPropagation(); // Detiene la propagación del clic
        });

        // Evitar que el clic dentro del área de entrada (input-area) propague el evento
        const inputArea = document.querySelector('.input-area');
        inputArea.addEventListener('click', function(event) {
            event.stopPropagation(); // Detiene la propagación del clic
        });

        // ----- Fin de las Modificaciones -----

        // Enviar mensaje al presionar "Enter"
        messageInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });

        // Función para enviar el mensaje
        function sendMessage() {
            const message = messageInput.value.trim();

            if (message.length > 60) { // Validación de longitud
                alert('El mensaje no puede tener más de 60 caracteres.');
                return;
            }

            if (message) {
                socket.emit('sendMessage', message);
                messageInput.value = ''; // Limpiar el campo de entrada
            }
        }

        // Recibir mensaje de otros jugadores
        socket.on('receiveMessage', (data) => {
            createMessageDiv(data.id, data.message);
            // Ya no es necesario mover los mensajes manualmente
        });

        // Actualizar la posición del mensaje al mover el jugador
        // function updateMessages() {
        //     for (const id in players) {
        //         moveMessage(id);
        //     }
        // }

        // setInterval(updateMessages, 60); 

        // Fragmento código desconexión por inactividad
        let inactivityTimer;

        function handleInactivity() {
            alert("Has estado inactivo durante 10 minutos. Actualiza la página para continuar pingüineando.");
            // Aquí puedes agregar el código para desconectar al usuario si es necesario
        }

        function resetInactivityTimer() {
            clearTimeout(inactivityTimer);
            inactivityTimer = setTimeout(handleInactivity, 600000);
        }

        document.addEventListener('keydown', resetInactivityTimer);
        document.addEventListener('mousemove', resetInactivityTimer);
        document.addEventListener('click', resetInactivityTimer);
        
        // Inicializar el temporizador al cargar la página
        resetInactivityTimer();
    </script>
</body>
</html>
